Answer questions marked as "QS"

QS1.1: What data structure do you use for implementing DFS? Why?
For implementing DFS, you would use a Stack (LIFO - Last In, First Out) data structure. You would want to use a LIFO structure, as DFS explores as deep as possible along a branch before backtracking if needed, which is supported how a stack is structured. You would push new nodes onto the stack as you explore the branch and pop them to backtrack if the search did not find the goal in that branch.

QS1.2: The Pacman board will show an overlay of the states explored, and the order in which they were explored (brighter red means earlier exploration). Is the exploration order what you would have expected? Does Pacman actually go to all the explored squares on his way to the goal?
The exploration order is expected, as Pacman follows from the brightest squares and goes down the final path to the more dim squares (later squares). Pacman does not visually goes down every single explored square on his way to the goal, as he only goes down the final path without backtracking.

QS2.1: What data structure do you use for implementing BFS? Why?
For implementing BFS, you would use a Queue (FIFO - First in, Last out) data structure. Since BFS explores all nodes at the current depth, a Queue would be ideal for this, as one could enqueue new nodes in the depth, and dequeue out the old nodes as they move down the depths.

QS3.1: What cost function did you use?  Please briefly describe how your cost function is designed (what factors does it consider and how heavy of a weight has each factor considered been given?)
Our cost function uses the SearchProblem's cost function and we pass that to the priority queue function. We're confused on what this question is referring to for designing a cost function, since we just used provided one. We don't know what the factors or weights are, since we're using the problem's given cost function.

QS4.1: What is the difference between the nullHeuristic  and the Manhattan distance heuristic? Does nullHeuristic give the optimal solution?  Why is the Manhattan distance heuristic better?
The difference between the Manhattan distance heuristic and nullHeuristic is that the nullHeuristic simply returns 0 for any state, giving no guidance. This essentially transform the A* search to be a UCS, which still finds the optimal path. The Manhattan distance heuristic is better as it gives more informed guidance, leading to less steps needed to find the optimal path.

QS4.2: What happens on openMaze for the various search strategies?
DFS chooses an extremely suboptimal path, while BFS and UCS find the optimal path but explore the entire maze with the same number of cells explored. A* with Manhattan Heuristic is the most efficient search, as it explores less paths. nullHeuristic reduces the A* search to a UCS, which is the same result as BFS.

QS5.1: What states representation do you choose in this problem?
Position and which corners we visited so far.

QS5.2: Briefly explain your implementation
Our startState is our initial position and an empty list. Our isGoalState is if we visited all of the corners (if the length of the visited list is 4). Our Successors check if the next state is one of the corners, and if it is we append it to the visited list. 

QS6.1: What heuristic did you use for this corner problem?  Explain the potential strong points and weak points of your chosen heuristic.  Is your heuristic consistent?  Why?
We took the max of the MazeDistance (which uses BFS) for each corner as the heuristic. The strong point is that we will guarantee the optimal path, we consider walls, and expand optimal amount of nodes. The weak point is that it takes a long time to compute the search. The heuristic is consistent as we will always underestimate the real path and will never stray away from the goal.

QS7.1: What heuristic did you use for this problem?  Explain the potential strong points and weak points of your chosen heuristic.  Is your heuristic consistent?  Why?
We did the same thing as Q6.1, where we used MazeDistance for each food pellet as the heuristic. The strengths and weaknesses are the same, but the precomputing for all of the food pellets was substantially long as there were many targets. The heuristic is consistent for the same reasons stated before.

Q8.1: Describe your solution and explain the potential strong points and weak points of your solution.
Our solution was to simply find the closest food pellet from the current position, using UCS. The weak point is that we do not expand like Manhattan tour heuristic because we do not consider future nodes. The strong point is that it is cheaper to only consider the nearest neighbor, as it only expanded 350 nodes in this case for us.